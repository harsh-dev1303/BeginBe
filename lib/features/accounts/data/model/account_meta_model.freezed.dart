// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'account_meta_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

AccountMetaModel _$AccountMetaModelFromJson(Map<String, dynamic> json) {
  return _AccountMetaModel.fromJson(json);
}

/// @nodoc
mixin _$AccountMetaModel {
  @JsonKey(name: "powered_by")
  String get poweredKey => throw _privateConstructorUsedError;
  @JsonKey(name: "upgrade_url")
  String get upgradeUrl => throw _privateConstructorUsedError;
  @JsonKey(name: "docs_url")
  String get docsUrl => throw _privateConstructorUsedError;
  @JsonKey(name: "template_gallery")
  String get templateGallery => throw _privateConstructorUsedError;
  @JsonKey(name: "message")
  String get mssg => throw _privateConstructorUsedError;
  @JsonKey(name: "features")
  List<String> get features => throw _privateConstructorUsedError;
  @JsonKey(name: "upgrade_cta")
  String get upgradeCta => throw _privateConstructorUsedError;

  /// Serializes this AccountMetaModel to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AccountMetaModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AccountMetaModelCopyWith<AccountMetaModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountMetaModelCopyWith<$Res> {
  factory $AccountMetaModelCopyWith(
    AccountMetaModel value,
    $Res Function(AccountMetaModel) then,
  ) = _$AccountMetaModelCopyWithImpl<$Res, AccountMetaModel>;
  @useResult
  $Res call({
    @JsonKey(name: "powered_by") String poweredKey,
    @JsonKey(name: "upgrade_url") String upgradeUrl,
    @JsonKey(name: "docs_url") String docsUrl,
    @JsonKey(name: "template_gallery") String templateGallery,
    @JsonKey(name: "message") String mssg,
    @JsonKey(name: "features") List<String> features,
    @JsonKey(name: "upgrade_cta") String upgradeCta,
  });
}

/// @nodoc
class _$AccountMetaModelCopyWithImpl<$Res, $Val extends AccountMetaModel>
    implements $AccountMetaModelCopyWith<$Res> {
  _$AccountMetaModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AccountMetaModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? poweredKey = null,
    Object? upgradeUrl = null,
    Object? docsUrl = null,
    Object? templateGallery = null,
    Object? mssg = null,
    Object? features = null,
    Object? upgradeCta = null,
  }) {
    return _then(
      _value.copyWith(
            poweredKey: null == poweredKey
                ? _value.poweredKey
                : poweredKey // ignore: cast_nullable_to_non_nullable
                      as String,
            upgradeUrl: null == upgradeUrl
                ? _value.upgradeUrl
                : upgradeUrl // ignore: cast_nullable_to_non_nullable
                      as String,
            docsUrl: null == docsUrl
                ? _value.docsUrl
                : docsUrl // ignore: cast_nullable_to_non_nullable
                      as String,
            templateGallery: null == templateGallery
                ? _value.templateGallery
                : templateGallery // ignore: cast_nullable_to_non_nullable
                      as String,
            mssg: null == mssg
                ? _value.mssg
                : mssg // ignore: cast_nullable_to_non_nullable
                      as String,
            features: null == features
                ? _value.features
                : features // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            upgradeCta: null == upgradeCta
                ? _value.upgradeCta
                : upgradeCta // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AccountMetaModelImplCopyWith<$Res>
    implements $AccountMetaModelCopyWith<$Res> {
  factory _$$AccountMetaModelImplCopyWith(
    _$AccountMetaModelImpl value,
    $Res Function(_$AccountMetaModelImpl) then,
  ) = __$$AccountMetaModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    @JsonKey(name: "powered_by") String poweredKey,
    @JsonKey(name: "upgrade_url") String upgradeUrl,
    @JsonKey(name: "docs_url") String docsUrl,
    @JsonKey(name: "template_gallery") String templateGallery,
    @JsonKey(name: "message") String mssg,
    @JsonKey(name: "features") List<String> features,
    @JsonKey(name: "upgrade_cta") String upgradeCta,
  });
}

/// @nodoc
class __$$AccountMetaModelImplCopyWithImpl<$Res>
    extends _$AccountMetaModelCopyWithImpl<$Res, _$AccountMetaModelImpl>
    implements _$$AccountMetaModelImplCopyWith<$Res> {
  __$$AccountMetaModelImplCopyWithImpl(
    _$AccountMetaModelImpl _value,
    $Res Function(_$AccountMetaModelImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AccountMetaModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? poweredKey = null,
    Object? upgradeUrl = null,
    Object? docsUrl = null,
    Object? templateGallery = null,
    Object? mssg = null,
    Object? features = null,
    Object? upgradeCta = null,
  }) {
    return _then(
      _$AccountMetaModelImpl(
        poweredKey: null == poweredKey
            ? _value.poweredKey
            : poweredKey // ignore: cast_nullable_to_non_nullable
                  as String,
        upgradeUrl: null == upgradeUrl
            ? _value.upgradeUrl
            : upgradeUrl // ignore: cast_nullable_to_non_nullable
                  as String,
        docsUrl: null == docsUrl
            ? _value.docsUrl
            : docsUrl // ignore: cast_nullable_to_non_nullable
                  as String,
        templateGallery: null == templateGallery
            ? _value.templateGallery
            : templateGallery // ignore: cast_nullable_to_non_nullable
                  as String,
        mssg: null == mssg
            ? _value.mssg
            : mssg // ignore: cast_nullable_to_non_nullable
                  as String,
        features: null == features
            ? _value._features
            : features // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        upgradeCta: null == upgradeCta
            ? _value.upgradeCta
            : upgradeCta // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AccountMetaModelImpl implements _AccountMetaModel {
  _$AccountMetaModelImpl({
    @JsonKey(name: "powered_by") required this.poweredKey,
    @JsonKey(name: "upgrade_url") required this.upgradeUrl,
    @JsonKey(name: "docs_url") required this.docsUrl,
    @JsonKey(name: "template_gallery") required this.templateGallery,
    @JsonKey(name: "message") required this.mssg,
    @JsonKey(name: "features") required final List<String> features,
    @JsonKey(name: "upgrade_cta") required this.upgradeCta,
  }) : _features = features;

  factory _$AccountMetaModelImpl.fromJson(Map<String, dynamic> json) =>
      _$$AccountMetaModelImplFromJson(json);

  @override
  @JsonKey(name: "powered_by")
  final String poweredKey;
  @override
  @JsonKey(name: "upgrade_url")
  final String upgradeUrl;
  @override
  @JsonKey(name: "docs_url")
  final String docsUrl;
  @override
  @JsonKey(name: "template_gallery")
  final String templateGallery;
  @override
  @JsonKey(name: "message")
  final String mssg;
  final List<String> _features;
  @override
  @JsonKey(name: "features")
  List<String> get features {
    if (_features is EqualUnmodifiableListView) return _features;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_features);
  }

  @override
  @JsonKey(name: "upgrade_cta")
  final String upgradeCta;

  @override
  String toString() {
    return 'AccountMetaModel(poweredKey: $poweredKey, upgradeUrl: $upgradeUrl, docsUrl: $docsUrl, templateGallery: $templateGallery, mssg: $mssg, features: $features, upgradeCta: $upgradeCta)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountMetaModelImpl &&
            (identical(other.poweredKey, poweredKey) ||
                other.poweredKey == poweredKey) &&
            (identical(other.upgradeUrl, upgradeUrl) ||
                other.upgradeUrl == upgradeUrl) &&
            (identical(other.docsUrl, docsUrl) || other.docsUrl == docsUrl) &&
            (identical(other.templateGallery, templateGallery) ||
                other.templateGallery == templateGallery) &&
            (identical(other.mssg, mssg) || other.mssg == mssg) &&
            const DeepCollectionEquality().equals(other._features, _features) &&
            (identical(other.upgradeCta, upgradeCta) ||
                other.upgradeCta == upgradeCta));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    poweredKey,
    upgradeUrl,
    docsUrl,
    templateGallery,
    mssg,
    const DeepCollectionEquality().hash(_features),
    upgradeCta,
  );

  /// Create a copy of AccountMetaModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountMetaModelImplCopyWith<_$AccountMetaModelImpl> get copyWith =>
      __$$AccountMetaModelImplCopyWithImpl<_$AccountMetaModelImpl>(
        this,
        _$identity,
      );

  @override
  Map<String, dynamic> toJson() {
    return _$$AccountMetaModelImplToJson(this);
  }
}

abstract class _AccountMetaModel implements AccountMetaModel {
  factory _AccountMetaModel({
    @JsonKey(name: "powered_by") required final String poweredKey,
    @JsonKey(name: "upgrade_url") required final String upgradeUrl,
    @JsonKey(name: "docs_url") required final String docsUrl,
    @JsonKey(name: "template_gallery") required final String templateGallery,
    @JsonKey(name: "message") required final String mssg,
    @JsonKey(name: "features") required final List<String> features,
    @JsonKey(name: "upgrade_cta") required final String upgradeCta,
  }) = _$AccountMetaModelImpl;

  factory _AccountMetaModel.fromJson(Map<String, dynamic> json) =
      _$AccountMetaModelImpl.fromJson;

  @override
  @JsonKey(name: "powered_by")
  String get poweredKey;
  @override
  @JsonKey(name: "upgrade_url")
  String get upgradeUrl;
  @override
  @JsonKey(name: "docs_url")
  String get docsUrl;
  @override
  @JsonKey(name: "template_gallery")
  String get templateGallery;
  @override
  @JsonKey(name: "message")
  String get mssg;
  @override
  @JsonKey(name: "features")
  List<String> get features;
  @override
  @JsonKey(name: "upgrade_cta")
  String get upgradeCta;

  /// Create a copy of AccountMetaModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccountMetaModelImplCopyWith<_$AccountMetaModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
