// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'account_meta.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

AccountMeta _$AccountMetaFromJson(Map<String, dynamic> json) {
  return _AccountMeta.fromJson(json);
}

/// @nodoc
mixin _$AccountMeta {
  @JsonKey(name: "powered_by")
  String get poweredBy => throw _privateConstructorUsedError;
  @JsonKey(name: "upgrade_url")
  String get upgradeUrl => throw _privateConstructorUsedError;
  @JsonKey(name: "docs_url")
  String get docsUrl => throw _privateConstructorUsedError;
  @JsonKey(name: "template_gallery")
  String get templateGallery => throw _privateConstructorUsedError;
  @JsonKey(name: "message")
  String get message => throw _privateConstructorUsedError;
  @JsonKey(name: "features")
  List<String> get features => throw _privateConstructorUsedError;
  @JsonKey(name: "upgrade_cta")
  String get upgradeCta => throw _privateConstructorUsedError;

  /// Serializes this AccountMeta to a JSON map.
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;

  /// Create a copy of AccountMeta
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AccountMetaCopyWith<AccountMeta> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountMetaCopyWith<$Res> {
  factory $AccountMetaCopyWith(
    AccountMeta value,
    $Res Function(AccountMeta) then,
  ) = _$AccountMetaCopyWithImpl<$Res, AccountMeta>;
  @useResult
  $Res call({
    @JsonKey(name: "powered_by") String poweredBy,
    @JsonKey(name: "upgrade_url") String upgradeUrl,
    @JsonKey(name: "docs_url") String docsUrl,
    @JsonKey(name: "template_gallery") String templateGallery,
    @JsonKey(name: "message") String message,
    @JsonKey(name: "features") List<String> features,
    @JsonKey(name: "upgrade_cta") String upgradeCta,
  });
}

/// @nodoc
class _$AccountMetaCopyWithImpl<$Res, $Val extends AccountMeta>
    implements $AccountMetaCopyWith<$Res> {
  _$AccountMetaCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AccountMeta
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? poweredBy = null,
    Object? upgradeUrl = null,
    Object? docsUrl = null,
    Object? templateGallery = null,
    Object? message = null,
    Object? features = null,
    Object? upgradeCta = null,
  }) {
    return _then(
      _value.copyWith(
            poweredBy: null == poweredBy
                ? _value.poweredBy
                : poweredBy // ignore: cast_nullable_to_non_nullable
                      as String,
            upgradeUrl: null == upgradeUrl
                ? _value.upgradeUrl
                : upgradeUrl // ignore: cast_nullable_to_non_nullable
                      as String,
            docsUrl: null == docsUrl
                ? _value.docsUrl
                : docsUrl // ignore: cast_nullable_to_non_nullable
                      as String,
            templateGallery: null == templateGallery
                ? _value.templateGallery
                : templateGallery // ignore: cast_nullable_to_non_nullable
                      as String,
            message: null == message
                ? _value.message
                : message // ignore: cast_nullable_to_non_nullable
                      as String,
            features: null == features
                ? _value.features
                : features // ignore: cast_nullable_to_non_nullable
                      as List<String>,
            upgradeCta: null == upgradeCta
                ? _value.upgradeCta
                : upgradeCta // ignore: cast_nullable_to_non_nullable
                      as String,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$AccountMetaImplCopyWith<$Res>
    implements $AccountMetaCopyWith<$Res> {
  factory _$$AccountMetaImplCopyWith(
    _$AccountMetaImpl value,
    $Res Function(_$AccountMetaImpl) then,
  ) = __$$AccountMetaImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    @JsonKey(name: "powered_by") String poweredBy,
    @JsonKey(name: "upgrade_url") String upgradeUrl,
    @JsonKey(name: "docs_url") String docsUrl,
    @JsonKey(name: "template_gallery") String templateGallery,
    @JsonKey(name: "message") String message,
    @JsonKey(name: "features") List<String> features,
    @JsonKey(name: "upgrade_cta") String upgradeCta,
  });
}

/// @nodoc
class __$$AccountMetaImplCopyWithImpl<$Res>
    extends _$AccountMetaCopyWithImpl<$Res, _$AccountMetaImpl>
    implements _$$AccountMetaImplCopyWith<$Res> {
  __$$AccountMetaImplCopyWithImpl(
    _$AccountMetaImpl _value,
    $Res Function(_$AccountMetaImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of AccountMeta
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? poweredBy = null,
    Object? upgradeUrl = null,
    Object? docsUrl = null,
    Object? templateGallery = null,
    Object? message = null,
    Object? features = null,
    Object? upgradeCta = null,
  }) {
    return _then(
      _$AccountMetaImpl(
        poweredBy: null == poweredBy
            ? _value.poweredBy
            : poweredBy // ignore: cast_nullable_to_non_nullable
                  as String,
        upgradeUrl: null == upgradeUrl
            ? _value.upgradeUrl
            : upgradeUrl // ignore: cast_nullable_to_non_nullable
                  as String,
        docsUrl: null == docsUrl
            ? _value.docsUrl
            : docsUrl // ignore: cast_nullable_to_non_nullable
                  as String,
        templateGallery: null == templateGallery
            ? _value.templateGallery
            : templateGallery // ignore: cast_nullable_to_non_nullable
                  as String,
        message: null == message
            ? _value.message
            : message // ignore: cast_nullable_to_non_nullable
                  as String,
        features: null == features
            ? _value._features
            : features // ignore: cast_nullable_to_non_nullable
                  as List<String>,
        upgradeCta: null == upgradeCta
            ? _value.upgradeCta
            : upgradeCta // ignore: cast_nullable_to_non_nullable
                  as String,
      ),
    );
  }
}

/// @nodoc
@JsonSerializable()
class _$AccountMetaImpl implements _AccountMeta {
  _$AccountMetaImpl({
    @JsonKey(name: "powered_by") required this.poweredBy,
    @JsonKey(name: "upgrade_url") required this.upgradeUrl,
    @JsonKey(name: "docs_url") required this.docsUrl,
    @JsonKey(name: "template_gallery") required this.templateGallery,
    @JsonKey(name: "message") required this.message,
    @JsonKey(name: "features") required final List<String> features,
    @JsonKey(name: "upgrade_cta") required this.upgradeCta,
  }) : _features = features;

  factory _$AccountMetaImpl.fromJson(Map<String, dynamic> json) =>
      _$$AccountMetaImplFromJson(json);

  @override
  @JsonKey(name: "powered_by")
  final String poweredBy;
  @override
  @JsonKey(name: "upgrade_url")
  final String upgradeUrl;
  @override
  @JsonKey(name: "docs_url")
  final String docsUrl;
  @override
  @JsonKey(name: "template_gallery")
  final String templateGallery;
  @override
  @JsonKey(name: "message")
  final String message;
  final List<String> _features;
  @override
  @JsonKey(name: "features")
  List<String> get features {
    if (_features is EqualUnmodifiableListView) return _features;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_features);
  }

  @override
  @JsonKey(name: "upgrade_cta")
  final String upgradeCta;

  @override
  String toString() {
    return 'AccountMeta(poweredBy: $poweredBy, upgradeUrl: $upgradeUrl, docsUrl: $docsUrl, templateGallery: $templateGallery, message: $message, features: $features, upgradeCta: $upgradeCta)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AccountMetaImpl &&
            (identical(other.poweredBy, poweredBy) ||
                other.poweredBy == poweredBy) &&
            (identical(other.upgradeUrl, upgradeUrl) ||
                other.upgradeUrl == upgradeUrl) &&
            (identical(other.docsUrl, docsUrl) || other.docsUrl == docsUrl) &&
            (identical(other.templateGallery, templateGallery) ||
                other.templateGallery == templateGallery) &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._features, _features) &&
            (identical(other.upgradeCta, upgradeCta) ||
                other.upgradeCta == upgradeCta));
  }

  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  int get hashCode => Object.hash(
    runtimeType,
    poweredBy,
    upgradeUrl,
    docsUrl,
    templateGallery,
    message,
    const DeepCollectionEquality().hash(_features),
    upgradeCta,
  );

  /// Create a copy of AccountMeta
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AccountMetaImplCopyWith<_$AccountMetaImpl> get copyWith =>
      __$$AccountMetaImplCopyWithImpl<_$AccountMetaImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$AccountMetaImplToJson(this);
  }
}

abstract class _AccountMeta implements AccountMeta {
  factory _AccountMeta({
    @JsonKey(name: "powered_by") required final String poweredBy,
    @JsonKey(name: "upgrade_url") required final String upgradeUrl,
    @JsonKey(name: "docs_url") required final String docsUrl,
    @JsonKey(name: "template_gallery") required final String templateGallery,
    @JsonKey(name: "message") required final String message,
    @JsonKey(name: "features") required final List<String> features,
    @JsonKey(name: "upgrade_cta") required final String upgradeCta,
  }) = _$AccountMetaImpl;

  factory _AccountMeta.fromJson(Map<String, dynamic> json) =
      _$AccountMetaImpl.fromJson;

  @override
  @JsonKey(name: "powered_by")
  String get poweredBy;
  @override
  @JsonKey(name: "upgrade_url")
  String get upgradeUrl;
  @override
  @JsonKey(name: "docs_url")
  String get docsUrl;
  @override
  @JsonKey(name: "template_gallery")
  String get templateGallery;
  @override
  @JsonKey(name: "message")
  String get message;
  @override
  @JsonKey(name: "features")
  List<String> get features;
  @override
  @JsonKey(name: "upgrade_cta")
  String get upgradeCta;

  /// Create a copy of AccountMeta
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AccountMetaImplCopyWith<_$AccountMetaImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
